## SELECT (Чтение строк из таблицы){#select}

`SELECT` используется для возврата вычислений на клиентскую сторону, в случае если он вызван без дополнительных конструкций, так как `FROM ...`, `INSERT INTO ...` и т.д.

Например, `SELECT` можно использовать для работы с датами, преобразования чисел или подсчета длины строки:
```sql
SELECT CURRENT_DATE + INTERVAL '1 day';  -- Возвращает завтрашнюю дату
SELECT LENGTH('Hello');  -- Возвращает длину строки 'Hello'
SELECT CAST('123' AS INTEGER);  -- Преобразует строки в числа
```

Такое применение `SELECT` бывает полезно при тестировании, отладки выражений или SQL-функций без обращения к реальной таблице, но чаще `SELECT` используется для получения строк из одной или множества таблиц. В самом простом представлении `SELECT` можно записать так: `SELECT <название столбца/столбцов> FROM <название таблицы>` или `SELECT <название_функции(< название столбца>)> FROM <название таблицы>;`. Чтобы прочитать все данные из таблицы, например, таблицы `movies` – нужно выполнить команду `SELECT * FROM movies;`, где  `*` – это оператор выбора данных по всем столбцам. При такой записи будут возвращены все строки из таблицы с данными по всем столбцам. Получить выборку строк таблицы по определенным столбцам можно перечислением названий столбцов после ключевого слова `SELECT`: `SELECT <название столбца>, <название столбца> FROM <название таблицы>;`. 

Вывести столбцы "title" и "director" для всех строк [таблицы](#create_table) "movies" можно так: `SELECT title, director FROM movies;`. Если в таблице много строк и нужно ограничить количество выводимых строк на печать – используется `LIMIT` с заданным количеством выводимых строк, который добавляется в конец инструкции `SELECT`.

Например, можно вывести только 5 строк таблицы `movies`:
```sql
SELECT title,director FROM movies LIMIT 5;
```  

Для выборки только части строк - используется оператор `WHERE` с условиями выборки: `SELECT <название столбца> FROM <название таблицы> WHERE <название столбца> <оператор условного сравнения> <значение столбца выборки>;` Например, можно выбрать все фильмы Джорджа Лукоса из нашей таблицы, созданные им после 1980 года:
```sql
SELECT * FROM movies WHERE director = 'George Lucas' AND date_prod > '1980-01-01';
```  

Можно добавить еще одно условие выборки, предположим по времени длительности фильма менее 2 часов. Сделать это можно добавлением оператора `AND` с указанием второго условия выборки. Такая запись может выглядеть так:
```sql
SELECT * FROM movies
WHERE length < INTERVAL '2 hours' AND date_prod < '1973-01-01';
``` 


По умолчанию база данных не гарантирует порядок возврата строк, и он может отличаться от запроса к запросу. Если требуется сохранить определенный порядок строк – используется инструкция `ORDER BY <название столбца для сортировки> <направление сортировки>`. Сортировка происходит по результатам, которые возвращает (`SELECT`), а не по исходным столбцам таблицы (`FROM`). Сортировать можно в прямом порядке – ASC (от меньшего к большему - вариант по умолчанию, можно не указывать) и в обратном – DESC (от большего к меньшему). Как сортировка будет выполняться, зависит от типа данных столбца. Например, строки хранятся в utf-8 и сравниваются по "unicode collate" (по кодам символов).


Отсортировать фильмы по убыванию даты производства от более новых, до более старых можно так:
```sql
SELECT title, director,date_prod FROM movies 
ORDER BY date_prod DESC;
```

`SELECT` можно применять к нескольким таблицам с указанием типа соединения таблиц. Объединение таблиц задается через оператор `JOIN`, который бывает следующих типов:
1. `INNER JOIN` (или просто JOIN) – возвращает строки, когда есть соответствующие значения в обеих таблицах. Исключает из результатов те строки, для которых нет совпадений в соединяемых таблицах.
2. `LEFT JOIN` (или LEFT OUTER JOIN) – возвращает все строки из левой таблицы и соответствующие строки из правой таблицы. Если нет совпадений, возвращает `NULL` для всех колонок правой таблицы.
3. `RIGHT JOIN` (или RIGHT OUTER JOIN) – возвращает все строки из правой таблицы и соответствующие строки из левой таблицы. Если не существует совпадений, возвращает `NULL` для всех колонок левой таблицы. Этот тип `JOIN` редко используется, так как его функциональность можно заменить `LEFT JOIN`, меняя местами таблицы.
4. `FULL JOIN` (или FULL OUTER JOIN) – возвращает как совпавшие, так и не совпавшие строки в обеих таблицах, при этом возвращает `NULL` в колонках из таблицы, для которой не найдено совпадение.
5. `CROSS JOIN` – возвращает комбинированный результат каждой строки левой таблицы с каждой строкой правой таблицы. Обычно используется, когда необходимо получить все возможные комбинации строк из двух таблиц.

Когда выполняется `JOIN` по определенному условию, например, по ключу, и в одной из таблиц есть несколько строк с одинаковым значением этого ключа, получается [декартово произведение](https://ru.wikipedia.org/wiki/Прямое_произведение). Это означает, что каждая строка из одной таблицы будет соединена с каждой соответствующей строкой из другой таблицы. На данный момент в PostgreSQL совместимости реализованы `INNER JOIN` и `CROSS JOIN`. `CROSS JOIN` просто комбинирует каждую строку одной таблицы с каждой строкой другой. `INNER JOIN` работает похожим образом, но добавляет фильтрацию. Этот фильтр определяется в части `ON` запроса. Таким образом, из всего декартова произведения выбираются только строки, соответствующие заданному условию.

Можно сказать, что `INNER JOIN` - это `CROSS JOIN`, но с дополнительной фильтрацией, или наоборот `CROSS JOIN` — это частный случай `INNER JOIN`, когда строки в обеих таблицах совпали. Если одна из таблиц пуста, результат объединения тоже будет пуст. `INNER JOIN` часто дает меньше строк на выходе, чем `CROSS JOIN`. `CROSS JOIN` объединяет строки без какого-либо условия, и поэтому в его синтаксисе отсутствуют ключевые слова `ON` или `USING`: `CROSS JOIN <название_таблицы> AS <алиас_таблицы>;`. В примере далее мы будем использовать `INNER JOIN`, синтаксис которого выглядит так: `INNER JOIN <название_таблицы> AS <алиас_таблицы> ON <алиас_первой_таблицы>.<имя_столбца> = <алиас_таблицы>.<соответствующее_имя_столбца>;`.

Вместо ключевого слова `ON` в `INNER JOIN` может использоваться `USING`. Использовать `USING` удобно, когда имена столбцов, по которым происходит соединение, в обеих таблицах совпадают. Синтаксис становится короче и чище: `INNER JOIN <название_таблицы> AS <алиас_таблицы> USING (<имя_столбца>);`. В одном SQL-запросе может быть N количество `JOIN` разных типов. Последовательность выполнения `JOIN` определяется их порядком в запросе и логикой выполнения запроса оптимизатором базы данных. 

Мы уже до этого создали [таблицу](#create_table) "movies", создадим ещё одну таблицу "lucas_actors":
```sql
CREATE TABLE lucas_actors (
    id SERIAL PRIMARY KEY,
    full_name TEXT NOT NULL,
    film TEXT NOT NULL,
    date_prod DATE NOT NULL,
    date_of_birth DATE,
    achievements TEXT
);
```

Заполним таблицу "lucas_actors" данными:
```sql
INSERT INTO lucas_actors (full_name, film, date_prod, date_of_birth, achievements) 
VALUES
('Harrison Ford', 'Indiana Jones and the Last Crusade', CAST('1989-05-24' AS DATE), CAST('1942-07-13' AS DATE), 'Oscar Nominee'),
('Richard Dreyfuss', 'American Graffiti', CAST('1973-08-01' AS DATE), CAST('1947-10-29' AS DATE), 'Oscar Winner'),
('Robert Duvall', 'THX 1138', CAST('1971-03-11' AS DATE), CAST('1931-01-05' AS DATE), 'Oscar Winner'),
('Liam Neeson', 'Star Wars: Episode I - The Phantom Menace', CAST('1999-05-19' AS DATE), CAST('1952-06-07' AS DATE), 'Oscar Nominee'),
('Ewan McGregor', 'Star Wars: Episode II - Attack of the Clones', CAST('2002-05-16' AS DATE), CAST('1971-03-31' AS DATE), 'Golden Globe Winner'),
('Hayden Christensen', 'Star Wars: Episode III - Revenge of the Sith', CAST('2005-05-19' AS DATE), CAST('1981-04-19' AS DATE), NULL);
```

Теперь применим оператор `INNER JOIN` для вывода в терминал полного имени актера (`full_name`), дня его рождения (`date_of_birth`), названия фильма (`title`) и даты производства фильма (`production_date`):
```sql
SELECT
    la.full_name,
    la.date_of_birth,
    f.title,
    f.production_date
FROM lucas_actors AS la
INNER JOIN movies AS f ON la.film = f.title;
```

Разберем подробнее как работает данный пример:
1. В строке `SELECT la.full_name, la.date_of_birth, f.title, f.production_date` производится выборка данных из двух таблиц представленных алиасами (псевдонимы): "f" –  таблица "movies", "la" – таблица "lucas_actors";
2. На строке `FROM lucas_actors AS la` задаются условия выборки строк из таблицы "lucas_actors" и задаётся алиас таблице конструкцией `AS la`.
3. На последней строчке `INNER JOIN movies AS f ON la.film = f.title;` с помощью оператора `INNER JOIN` производится соединение по столбцу "film" из таблицы "lucas_actors" и столбцу "title" таблицы "movies".

В результате выполнения приведенного выше SQL-запроса будет получен следующий результат:
|   full_name     | date_of_birth | title                                         | production_date  |
|-----------------|---------------|-----------------------------------------------|------------------|
| Harrison Ford   | 1942-07-13    | Indiana Jones and the Last Crusade            |    1989-05-24    |
| Richard Dreyfuss| 1947-10-29    | American Graffiti                             |    1973-08-01    |
| Robert Duvall   | 1931-01-05    | THX 1138                                      |    1971-03-11    |
| Liam Neeson     | 1952-06-07    | Star Wars: Episode I - The Phantom Menace     |    1999-05-19    |

